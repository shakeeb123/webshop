(dp1
S'output'
p2
S"<type 'exceptions.KeyError'> 'amount'"
p3
sS'layer'
p4
S'D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py'
p5
sS'code'
p6
S'# -*- coding: utf-8 -*-\nimport json\n\n#Internal method\ndef __valid_product(product_name):\n\t"""\n\t"""\n\tproduct_name = db.product_catalog.name == product_name\n\tquery = db(product_name).select().first()\n\tif query.amount > 0:\n\t\treturn True\n\treturn False\n\n#Commonly used response\ndef bad_product():\n\t"""\n\tReturns the values that the token was bad so it needs to be made again with the get_token function.\n\t"""\n\treturn dict(success = False, reason = "Not a valid product.")\n\ndef add_product():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tproduct_amount = int(data["amount"])\n\tproduct_price = int(data["price"])\n\n\tproduct_id = db.product_catalog.insert(name = product_name, amount = product_amount, price = product_price)\n\treturn dict(success = True, product_id = product_id)\n\ndef edit_product():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tproduct_amount = int(data["amount"])\n\tproduct_price = int(data["price"])\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'bad_product.json\')\n\n\tquery = db.product_catalog.name == product_name\n\tdb(query).update(amount = product_amount, price = product_price)\n\treturn dict(success = True)\n\ndef remove_product():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'bad_product.json\')\n\n\tquery = db.product_catalog.name == product_name\n\tdb(query).delete()\n\tdb.commit()\n\treturn dict(success = True)\n\ndef add_product_to_basket():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tpurchase_amount = int(data["amount"])\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'bad_product.json\')\n\n\tquery = db.product_catalog.name == product_name\n\tproduct = db(query).select().first()\n\n\tquery2 = db.shopping_basket.name == product_name\n\tbasket_entry = db(query2).select().first()\n\n\tif product.name == basket_entry.name:\n\t\treturn dict(success = False, reason = "Product already in basket.")\n\tif product.amount > purchase_amount:\n\t\tproduct_id = db.shopping_basket.insert(name = product_name, catalog_id = product.id , purchase_amount = purchase_amount)\n\t\tnew_amount = product.amount - purchase_amount\n\t\tdb(query).update(amount = new_amount)\n\t\treturn dict(success = True, product_id = product_id)\n\telse:\n\t\treturn dict(success = False, reason = "Product not available.")\t\n\t\ndef edit_product_from_basket():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tpurchase_amount = int(data["amount"])\n\tif not __valid_product(product_name):\n\t\tredirect(\'bad_product.json\')\n\n\tquery = db.shopping_basket.name == product_name\n\tbasket_entry = db(query).select().first()\n\n\tquery2 = db.product_catalog.name == product_name\n\tproduct = db(query2).select().first()\n\n\tif not basket_entry:\n\t\treturn dict(success = False, reason = "Product not in basket.")\n\n\tdb(query).update(amount = purchase_amount)\n\tnew_amount = basket_entry.amount + product.amount - purchase_amount\n\tdb(query2).update(amount = new_amount)\n\treturn dict(success = True)\t\n\t\t\n\ndef remove_product_from_basket():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\t\n\tif not __valid_product(product_name):\n\t\tredirect(\'bad_product.json\')\n\n\tquery = db.shopping_basket.name == product_name\n\tbasket_entry = db(query).select().first()\n\n\tquery2 = db.product_catalog.name == product_name\n\tproduct = db(query2).select().first()\n\n\tif basket_entry:\n\t\tnew_amount = basket_entry.amount + product.amount\n\t\tprint new_amount\n\t\tdb(query).delete()\n\t\tdb(query2).update(amount = new_amount)\n\t\treturn dict(success = True)\n\telse:\n\t\treturn dict(success = False, reason = "Product not in basket.")\n\ndef query_products_from_catalog():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tif not __valid_product(data["name"]):\n\t\tredirect(\'bad_product.json\')\t\n\tif data["name"]:\n\t\tproduct_name = data["name"]\n\t\tquery = db(db.product_catalog.name.contains(product_name))\n\tif data["price"]:\n\t\tproduct_price = data["price"]\n\t\tquery = db(db.product_catalog.price == product_price)\n\tif data["min_price"]:\n\t\tmin_price = data["min_price"]\n\t\tmin_range = db.product_catalog.price > min_price\n\tif data["max_price"]:\n\t\tmax_price = data["max_price"]\n\t\tmax_range = db.product_catalog.price < max_price\n\tif min_price & max_price:\n\t\tprice_range = min_range & max_range\n\tpagination = 100\n\tsorting_parameter = data["sort"]\n\tif sorting_parameter:\n\t\trows = query.select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter))\n\telif sorting_parameter & price_range:\n\t\trows = query.select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter),\n\t\t\tgroupby = db.product_catalog.name, having = price_range)\n\telse:\n\t\trows = query.select(limitby = pagination, orderby = db.product_catalog.name)\n\treturn dict(success = True, rows = rows)\n\ndef query_products_from_basket():\n\t"""\n\t"""\n\tdata = json.loads(request.body.read())\n\tif not __valid_product(data["name"]):\n\t\tredirect(\'bad_product.json\')\t\n\tif data["name"]:\n\t\tproduct_name = data["name"]\n\t\tquery = db(db.shopping_basket.name.contains(product_name))\n\tif data["price"]:\n\t\tproduct_price = data["price"]\n\t\tquery = db(db.product_catalog.price == product_price)\n\tif data["min_price"]:\n\t\tmin_price = data["min_price"]\n\t\tmin_range = db.product_catalog.price > min_price\n\tif data["max_price"]:\n\t\tmax_price = data["max_price"]\n\t\tmax_range = db.product_catalog.price < max_price\n\tif min_price & max_price:\n\t\tprice_range = min_range & max_range\n\tpagination = 100\n\tsorting_parameter = data["sort"]\n\tif sorting_parameter:\n\t\trows = query.select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter))\n\telif sorting_parameter & price_range:\n\t\trows = query.select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter),\n\t\t\tgroupby = db.product_catalog.name, having = price_range)\n\telse:\n\t\trows = query.select(limitby = pagination, orderby = db.product_catalog.name)\n\treturn dict(success = True, rows = rows)\n\n#API Features\n# def get_token():\n# \t"""\n# \tTake a username and password and return a token if valid.\n# \tNOTE: Tokens should be used in ALL methods except this one.\n# \t"""\n# \tdata = json.loads(request.body.read())\n# \tif not data["username"] and data["password"]:\n# \t\treturn dict(success = False, reason = "No username and password provided.")\n# \tusername = data["username"]\n# \tpassword = data["password"]\n# \tuser_details = db(db.auth_user.username == username).select().first()\n# \tif not user_details:\n# \t\treturn dict(success = False, reason = "No valid username or password.")\n# \t#Check the password of that user.\n# \tsalted_password = db.auth_user.password.validate(password)[0]\n# \tif not user_details.password == salted_password:\n# \t\treturn dict(success = False, reason = "No valid username or password.")\n# \t#Create a token for that user\n# \timport uuid\n# \timport time\n# \ttoken = str(uuid.uuid1())\n# \tdb.api_token.insert(token = token, username = username)\n# \treturn dict(success = True, token = token)\n\t\n# def user_details():\n# \t"""\n# \tGet\'s the auth.user.id of the user that is currently logged in with this token.\n# \t"""\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tusername = db(db.api_token.token == token).select().first().username\n# \tuser_id = db(db.auth_user.username == username).select().first().id\n# \treturn dict(user_id = user_id, success = True)\n\n# def pending_artifacts():\n# \t"""\n# \tGet\'s the pending artifacts for a particular user based on username.\n# \t"""\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tusername = data["username"]\n# \tartifact = db.artifact_revision.id > 0\n# \trevised_artifact = db.artifact.id == db.artifact_revision.artifact_id\n# \tartifact_type = db.artifact_type.id == db.artifact.artifact_type_id\n# \tuser_email = db(db.auth_user.username == username).select().first().email\n# \tapprover = db.review_cycle_step_definition.approver_email.contains(user_email)\n# \tupdated_artifacts = artifact & revised_artifact & artifact_type & approver\n# \tprocess_artifacts = db(updated_artifacts).select()\n# \treview_count = len(process_artifacts)\n# \tpending = []\n# \tfor item in process_artifacts:\n# \t\tpending.append({"name":item.artifact.name,\n# \t\t\t\t\t"revision_number":item.artifact_revision.revision_number})\n# \treturn dict(pending = pending, success = True)\n\n# def token_info():\n# \t"""\n# \tShow information about the token.  It can be an expired token at this point.\n# \t"""\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tdata = db(db.api_token.token == token).select().first()\n# \treturn dict(data = data,success = True, valid = __valid_token(token))\n\n# def delete_token():\n# \t"""\n# \tTakes a token and if valid will make it invalid be deleting it.\n# \t#TODO Should make as invalid not delete.\n# \t"""\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tdb(db.api_token.token == token).delete()\n# \treturn dict(success = True)\n\n# def deployment_request():\n# \tif deployment_target_type_name == \'PROSPER\':\n# \t\tfile_transfer_scp()\n# \telse:\n# \t\tfile_transfer_sftp()\n# \treturn\n\t\n# def deployment_received():\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tdeployment_id = data["deployment_id"]\t\n# \tuser_data = db(db.api_token.token == token).select().first().username\n# \tdeployment_data = db(db.deployment_queue.deployment_package_id == deployment_id)\n# \tdeployment_check = db(db.deployment_history.deployment_package_id == deployment_id)\n# \tdeploy = deployment_data.select().first()\n# \tdeploy_check = deployment_check.select().first()\n# \tif not deploy:\n# \t\treason = "Not a valid deployment_id: {!s}".format(deployment_id)\n# \t\treturn dict(reason = reason, success = False)\n# \telse:\n# \t\tif deploy.status == \'queued\':\n# \t \t\tactivity(logged_username = user_data,\n# \t\t\t\t\tmessage_data = \'DEPLOYMENT RECEIVED BY {!s} for deployment ID: {!s}\'.format(user_data,deployment_id),db=db)\n# \t\t\tdb.deployment_history.insert(artifact_id = deploy_check.artifact_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_target_type_id = deploy_check.deployment_target_type_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_package_id = deployment_id,\n# \t\t\t\t\t\t\t\t\t\tstatus = \'received\')\n# \t\t\tdb.commit()\n# \t\t\tdeployment_data.update(status = \'done\')\t\t\t\n# \t\t\treturn dict(success = True)\n# \t\telse:\n# \t\t\treason = "Already deployed - deployment_id: {!s}".format(deployment_id)\n# \t\t\treturn dict(reason = reason , success = False)\n\n# def deployment_processed():\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tdeployment_id = data["deployment_id"]\t\n# \tuser_data = db(db.api_token.token == token).select().first().username\n# \tdeployment_data = db(db.deployment_queue.deployment_package_id == deployment_id)\n# \tdeployment_check = db(db.deployment_history.deployment_package_id == deployment_id)\n# \tdeploy = deployment_data.select().first()\n# \tdeploy_check = deployment_check.select().first()\n# \tif not deploy:\n# \t\treturn dict(reason = "Not a valid deployment_id: {!s}".format(deployment_id), success = False)\n# \telse:\n# \t\tif deploy.status == \'done\':\n# \t \t\tactivity(logged_username = user_data,\n# \t\t\t\t\tmessage_data = \'DEPLOYMENT PROCESSED BY {!s} for deployment ID: {!s}\'.format(user_data,deployment_id),db=db)\n# \t\t\tdb.deployment_history.insert(artifact_id = deploy_check.artifact_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_target_type_id = deploy_check.deployment_target_type_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_package_id = deployment_id,\n# \t\t\t\t\t\t\t\t\t\tstatus = \'processed\')\n# \t\t\tdb.commit()\n# \t \t\tdeployment_data.update(status = \'processed\')\n# \t \t\treturn dict(success = True)\n# \t\telse:\n# \t\t\treason = "Already processed - deployment_id: {!s}".format(deployment_id)\n# \t\t\treturn dict(reason = reason , success = False)\n\n# def deployment_activated():\n# \tdata = json.loads(request.body.read())\n# \ttoken = data["token"]\n# \tif not __valid_token(token):\n# \t\tredirect(\'bad_token.json\')\n# \tdeployment_id = data["deployment_id"]\t\n# \tuser_data = db(db.api_token.token == token).select().first().username\n# \tdeployment_data = db(db.deployment_queue.deployment_package_id == deployment_id)\n# \tdeployment_check = db(db.deployment_history.deployment_package_id == deployment_id)\n# \tdeploy = deployment_data.select().first()\n# \tdeploy_check = deployment_check.select().first()\n# \tif not deploy:\n# \t\treason = "Not a valid deployment_id: {!s}".format(deployment_id)\n# \t\treturn dict(reason = reason , success = False)\n# \telse:\n# \t\tif deploy.status == \'processed\':\n# \t \t\tactivity(logged_username = user_data,\n# \t\t\t\t\tmessage_data = \'DEPLOYMENT ACTIVATED BY {!s} for deployment ID: {!s}\'.format(user_data,deployment_id),db=db)\n# \t\t\tdb.deployment_history.insert(artifact_id = deploy_check.artifact_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_target_type_id = deploy_check.deployment_target_type_id,\n# \t\t\t\t\t\t\t\t\t\tdeployment_package_id = deployment_id,\n# \t\t\t\t\t\t\t\t\t\tstatus = \'activated\')\n# \t\t\tdb.commit()\n# \t \t\tdb(db.deployment_queue.deployment_package_id == deployment_id).delete()\n# \t\t\treturn dict(success = True)\n# \t\telse:\n# \t\t\treason = "Already activated - deployment_id: {!s}".format(deployment_id)\n# \t\t\treturn dict(reason = reason , success = False)\n\nresponse._vars=response._caller(edit_product_from_basket)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "D:\\web2py_win\\web2py\\gluon\\restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py", line 381, in <module>\n  File "D:\\web2py_win\\web2py\\gluon\\globals.py", line 412, in <lambda>\n    self._caller = lambda f: f()\n  File "D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py", line 105, in edit_product_from_basket\n    db(query).update(amount = purchase_amount)\n  File "D:\\web2py_win\\web2py\\gluon\\packages\\dal\\pydal\\objects.py", line 2031, in update\n    if any(f(self,update_fields) for f in table._before_update):\n  File "D:\\web2py_win\\web2py\\gluon\\packages\\dal\\pydal\\objects.py", line 2031, in <genexpr>\n    if any(f(self,update_fields) for f in table._before_update):\n  File "D:\\web2py_win\\web2py\\gluon\\packages\\dal\\pydal\\objects.py", line 2087, in delete_uploaded_files\n    fields = [f for f in fields if table[f].type == \'upload\'\n  File "D:\\web2py_win\\web2py\\gluon\\packages\\dal\\pydal\\objects.py", line 508, in __getitem__\n    return super(Table, self).__getitem__(key)\n  File "D:\\web2py_win\\web2py\\gluon\\packages\\dal\\pydal\\helpers\\classes.py", line 24, in __getitem__\n    return self.__dict__.__getitem__(str(key))\nKeyError: \'amount\'\n'
p11
s.