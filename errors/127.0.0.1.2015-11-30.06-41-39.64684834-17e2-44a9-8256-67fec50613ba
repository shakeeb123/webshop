(dp1
S'output'
p2
S"<type 'exceptions.UnboundLocalError'> local variable 'min_price' referenced before assignment"
p3
sS'layer'
p4
S'D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py'
p5
sS'code'
p6
S'# -*- coding: utf-8 -*-\nimport json\n\n#Internal method\ndef __valid_product(product_name):\n\t"""\n\tThis call is used to validate the existence of product in catalog with amount because if there is amount, product is not valid for shopping\n\t"""\n\tproduct_name = db.product_catalog.name == product_name\n\tquery = db(product_name).select().first()\n\tif query.amount > 0:\n\t\treturn True\n\treturn False\n\n#Commonly used response\ndef invalid_product():\n\t"""\n\tReturns the values that the product mentioned was invalid and data needs to be provided again.\n\t"""\n\treturn dict(success = False, reason = "Not a valid product.")\n\n#API Features\ndef add_product():\n\t"""\n\tThis call checks if the product is already added in catalog database, otherwise adds the product and returns its product ID.\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tproduct_amount = int(data["amount"])\n\tproduct_price = int(data["price"])\n\tproduct = db.product_catalog.name == product_name\n\tquery = db(product).select().first()\n\tif query:\n\t\treturn dict(success = False, reason = "Product already in catalog.")\n\tproduct_id = db.product_catalog.insert(name = product_name, amount = product_amount, price = product_price)\n\treturn dict(success = True, product_id = product_id)\n\ndef edit_product():\n\t"""\n\tThis call lets you edit any product after checking its validity and lets you update price or amount or both in catalog .\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'invalid_product.json\')\n\n\tproduct_amount = int(data["amount"])\n\tproduct_price = int(data["price"])\n\n\tquery = db.product_catalog.name == product_name\n\tif product_amount and product_price:\n\t\tdb(query).update(amount = product_amount, price = product_price)\n\t\treturn dict(success = True, reason = \'Amount and Price updated\')\n\t\n\telif product_amount:\n\t\tdb(query).update(amount = product_amount)\n\t\treturn dict(success = True, reason = \'Amount updated\')\n\t\n\telif product_price:\n\t\tdb(query).update(price = product_price)\n\t\treturn dict(success = True, reason = \'Price updated\')\n\ndef remove_product():\n\t"""\n\tThis call is used to remove any product from catalog deleting all the information related to amount and price of the product.\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'invalid_product.json\')\n\n\tquery = db.product_catalog.name == product_name\n\tdb(query).delete()\n\tdb.commit()\n\treturn dict(success = True, reason = \'Product successfully removed from catalog\')\n\ndef add_product_to_basket():\n\t"""\n\tThis call checks if the product is already added in shopping basket, otherwise adds the product and returns its product ID.\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tpurchase_amount = int(data["amount"])\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'invalid_product.json\')\n\n\tquery = db.product_catalog.name == product_name\n\tproduct = db(query).select().first()\n\n\tquery2 = db.shopping_basket.name == product_name\n\tbasket_entry = db(query2).select().first()\n\n\tif basket_entry:\n\t\tif product.name == basket_entry.name:\n\t\t\treturn dict(success = False, reason = "Product already in basket.")\n\n\tif product.amount > purchase_amount:\n\t\tproduct_id = db.shopping_basket.insert(name = product_name, catalog_id = product.id , purchase_amount = purchase_amount)\n\t\tnew_amount = product.amount - purchase_amount\n\t\tdb(query).update(amount = new_amount)\n\t\treturn dict(success = True, product_id = product_id)\n\n\telse:\n\t\treturn dict(success = False, reason = "Product not available.")\t\n\t\ndef edit_product_from_basket():\n\t"""\n\tThis call lets you edit any product from shopping basket after checking its validity and lets you update purchase amount in basket \n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\tpurchase_amount = int(data["amount"])\n\n\tif not __valid_product(product_name):\n\t\tredirect(\'invalid_product.json\')\n\n\tquery = db.shopping_basket.name == product_name\n\tbasket_entry = db(query).select().first()\n\n\tquery2 = db.product_catalog.name == product_name\n\tproduct = db(query2).select().first()\n\n\tif basket_entry:\t\t\n\t\tdb(query).update(purchase_amount = purchase_amount)\n\t\tnew_amount = basket_entry.purchase_amount + product.amount - purchase_amount\n\t\tdb(query2).update(amount = new_amount)\n\t\treturn dict(success = True, reason = \'Basket successfully updated\')\t\n\telse:\n\t\treturn dict(success = False, reason = "Product not in basket.")\n\t\t\ndef remove_product_from_basket():\n\t"""\n\tThis call is used to remove any product from shopping basket deleting all the information related to purchase amount of the product.\n\t"""\n\tdata = json.loads(request.body.read())\n\tproduct_name = data["name"]\n\t\n\tif not __valid_product(product_name):\n\t\tredirect(\'invalid_product.json\')\n\n\tquery = db.shopping_basket.name == product_name\n\tbasket_entry = db(query).select().first()\n\n\tquery2 = db.product_catalog.name == product_name\n\tproduct = db(query2).select().first()\n\n\tif basket_entry:\n\t\tnew_amount = basket_entry.purchase_amount + product.amount\n\t\tdb(query).delete()\n\t\tdb(query2).update(amount = new_amount)\n\t\tdb.commit()\n\t\treturn dict(success = True, reason = \'Product successfully removed from catalog\')\n\telse:\n\t\treturn dict(success = False, reason = "Product not in basket.")\n\t\t\ndef query_products_from_catalog():\n\t"""\n\tThis call is used to query products from catalog based on name or price or price range, sort it according to name or price and group the\n\tproducts by specified price range.\n\t"""\n\tdata = json.loads(request.body.read())\n\tpagination = (0,100) \n\t\n\tif data.has_key("sort"):\n\t\tsorting_parameter = data["sort"]\n\n\tif data.has_key("name"):\n\t\tproduct_name = data["name"]\n\t\tquery = db.product_catalog.name.contains(product_name)\n\n\telif data.has_key("price"):\n\t\tproduct_price = int(data["price"])\n\t\tquery = db.product_catalog.price == product_price\n\n\telse:\n\t\tquery = db.product_catalog.id > 0\n\t\n\tif data.has_key("min_price"):\n\t\tmin_price = int(data["min_price"])\n\t\tmin_range = db.product_catalog.price > min_price \n\t\tquery2 = min_range\n\n\tif data.has_key("max_price"):\n\t\tmax_price = int(data["max_price"])\n\t\tmax_range = db.product_catalog.price < max_price \n\t\tquery2 = max_range\n\t\t\n\tif data.has_key("min_price") & data.has_key("max_price"):\n\t\tprice_range = min_range & max_range\n\t\tquery2 = price_range\n\n\tif sorting_parameter:\n\t\trows = db(query).select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter))\n\n\telif query2 != None:\n\t\trows = db(query).select(\n\t\t\tlimitby = pagination,\n\t\t\tgroupby = db.product_catalog.name, having = query2)\n\n\telif query2 != None and sorting_parameter:\n\t\trows = db(query).select(\n\t\t\tlimitby = pagination,\n\t\t\torderby = getattr(db.product_catalog,sorting_parameter),\n\t\t\tgroupby = db.product_catalog.name, having = query2)\n\n\telse:\n\t\trows = db(query).select(limitby = pagination, orderby = db.product_catalog.name)\n\n\treturn dict(success = True, products = rows)\n\ndef query_products_from_basket():\n\t"""\n\tThis call is used to query products from shopping basket based on name or price or price range, sort it according to name or price \n\tand group the products by specified price range.\n\t"""\n\tdata = json.loads(request.body.read())\n\tpagination = (0,100) \n\n\tif data.has_key("sort"):\n\t\tsorting_parameter = data["sort"]\n\n\tif data.has_key("min_price"):\n\t\tmin_price = int(data["min_price"])\n\n\tif data.has_key("max_price"):\n\t\tmax_price = data["max_price"]\n\n\tif data.has_key("name"):\n\t\tproduct_name = data["name"]\n\t\tquery = db.shopping_basket.name.contains(product_name)\n\t\tquery2 = db.shopping_basket.catalog_id == db.product_catalog.id\n\t\tquery3 = query & query2\n\t\trows = db(query3).select(limitby = pagination)\n\n\telif data.has_key("price"):\n\t\tproduct_price = int(data["price"])\n\t\tprint product_price\n\t\tquery = db.product_catalog.price == product_price\n\t\tquery2 = db.shopping_basket.catalog_id == db.product_catalog.id\n\t\tquery3 = query & query2\n\t\trows = db(query3).select(limitby = pagination)\n\n\telse:\n\t\tquery = db.shopping_basket.catalog_id == db.product_catalog.id\n\t\trows = db(query).select(limitby = pagination)\n\t\n\tif sorting_parameter:\n\t\tif sorting_parameter  == \'price\':\n\t\t\tresults = rows.sort(lambda row: row.product_catalog.price)\n\t\t\n\t\t\tif min_price:\n\t\t\t\tresults = rows.find(lambda row: row.product_catalog.price > min_price).sort(lambda row: row.product_catalog.price)\n\t\t\t\n\t\t\telif max_price:\n\t\t\t\tresults = rows.find(lambda row: row.product_catalog.price < max_price).sort(lambda row: row.product_catalog.price)\n\t\t\t\n\t\t\telif min_price and max_price:\n\t\t\t\tresults = rows.find(lambda row: row.product_catalog.price > min_price and row.product_catalog.price < max_price).sort(\n\t\t\t\t\t\t\t\t\tlambda row: row.product_catalog.price)\n\t\telse:\n\t\t\tresults = rows.sort(lambda row: row.shopping_basket.name)\n\telse:\n\t\tresults = rows\n\n\treturn dict(success = True, products = results)\nresponse._vars=response._caller(query_products_from_basket)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "D:\\web2py_win\\web2py\\gluon\\restricted.py", line 227, in restricted\n    exec ccode in environment\n  File "D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py", line 271, in <module>\n  File "D:\\web2py_win\\web2py\\gluon\\globals.py", line 412, in <lambda>\n    self._caller = lambda f: f()\n  File "D:\\web2py_win\\web2py\\applications\\webshop\\controllers/webshop_api.py", line 256, in query_products_from_basket\n    if min_price:\nUnboundLocalError: local variable \'min_price\' referenced before assignment\n'
p11
s.